# Recursive Functions

> A function is called recursive if the body of that function calls itself, either directly or indirectly.

```py
def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)
```

# 1. Mutual Recursion

Credit Card: Luhn Algorithm

```py
def split(n):
    return n // 10, n % 10

def sum_digits(n):
    if n < 10:
        return n
    else:
        all_but_last, last = split(n)
        return sum_digits(all_but_last) + last

def luhn_sum(n):
    if n < 10:
        return n
    else:
        all_but_last, last = split(n)
        return luhn_sum_double(all_but_last) + last

def luhn_sum_double(n):
    all_but_last, last = split(n)
    luhn_digit = sum_digits(2 * last)
    if n < 10:
        return luhn_digit
    else:
        return luhn_sum(all_but_last) + luhn_digit
```

# 2. Iteration VS Recursion

**Iteration is a special case of recursion.**

## Recursion to Iteration

Idea: Figure out what state must be maintained by the iterative function.

```py
def split(n):
    return n // 10, n % 10

```

- Recursion:

```py
def sum_digits(n):
    if n < 10:
        return n
    else:
        all_but_last, last = split(n)
        return sum_digits(all_but_last) + last
```

- Iteration:

```py
def sum_digits_iter(n):
    digit_sum = 0
    while n > 0:
        n, last = split(n)
        digit_sum += last
    return digit_sum
```

## Iteration to Recursion

Idea: The state of an iteration can be passed as arguments.

- Iteration:

```py
def sum_digits_iter(n):
    digit_sum = 0
    while n > 0:
        n, last = split(n)
        digit_sum += last
    return digit_sum
```

- Recursion:

```py
def sum_digits_rec(n, digit_sum):
    if n == 0:
        return digit_sum
    else:
        n, last = split(n)
        return sum_digits_rec(n, digit_sum + last)
```

# 3. Order of Recursive Calls

```py
def cascade(num):
    if num < 10:
        print(num)
    else:
        print(num)
        cascade(num // 10)
        print(num)

cascade(2013)
# 2013
# 201
# 20
# 2
# 20
# 201
# 2013
```

## Inverse cascade

```py
# 1
# 12
# 123
# 1234
# 123
# 12
# 1
def inverse_cascade(n):
    grow(n)
    print(n)
    shrink(n)

def f_then_g(f, g, n):
    if n:
        f(n)
        g(n)

grow = lambda n: f_then_g(grow, print, n // 10)
shrink = lambda n: f_then_g(print, shrink, n // 10)

inverse_cascade(1234)
```

# 4. Tree Recursion

> Tree-shaped processes arise whenever executing the body of a recursive function makes more than one call to that function.

![Snipaste_2022-08-22_19-22-15.png](https://media.haochen.me/Snipaste_2022-08-22_19-22-15.png)

The process is highly repetitive; fib is called on the same argument multiple times.

```py
def paths(m, n):
    """Return the number of paths from one corner of an M by N grid to the opposite corner.
    >>> paths(2, 2)
    2
    >>> paths(5, 7)
    210
    >>> paths(117, 1)
    1
    >>> paths(1, 157)
    1
    """
    if m == 0 or n == 0:
        return 1
    return paths(m-1, n) + paths(m, n-1)
```

# Counting Partitions

The number of partitions of a positive integer `n`, using parts up to size `m`, is the number of ways in which `n` can be expressed as the sum of positive integer parts up to `m` in increasing order.
